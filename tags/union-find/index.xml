<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Union Find on Air Junda Space</title>
    <link>https://airjunda.github.io/tags/union-find/</link>
    <description>Recent content in Union Find on Air Junda Space</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2021. All rights reserved.</copyright>
    <lastBuildDate>Fri, 04 Feb 2022 01:55:43 +0800</lastBuildDate><atom:link href="https://airjunda.github.io/tags/union-find/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Union Find 复习</title>
      <link>https://airjunda.github.io/post/unionfind/</link>
      <pubDate>Fri, 04 Feb 2022 01:55:43 +0800</pubDate>
      
      <guid>https://airjunda.github.io/post/unionfind/</guid>
      <description>Union Find 一种用于解决一个图的2个点是否相互连通的数据结构。比BFS高效。复习可以用下面这2题来回忆: 589 连接图 590 连接图 II
运用： 434 · 岛屿的个数II
UnionFind的模板写法如下：
class UnionFind: def __init__(self, N): self.root = [i for i in range(N)] self.cnt = N def find(self, k): if self.root[k] == k: return k self.root[k] = self.find(self.root[k]) return self.root[k] def union(self, a, b): x = self.find(a) y = self.find(b) if x != y: self.root[y] = x self.cnt -= 1 return 并查集原生操作：
 合并两个元素所在的集合 Union 查询元素的老大是谁 Find 查询两个元素是否在同一个帮派  并查集的派生操作：</description>
    </item>
    
  </channel>
</rss>
